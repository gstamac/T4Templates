<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ include file="T4Toolbox.tt" #>
<#@ output extension=".Generated.cs" #>
<#
	if (Session.ContainsKey("InputFileName"))
	{
		FileCodeModel codeModel = GetCodeModel(Session["InputFileName"] as string);

		WriteLine("/*");
		//DumpElements(codeModel.CodeElements);
		WriteLine("*/");

		OutputUsings();

		ProcessElements(codeModel.CodeElements);
	} else {
		WriteLine("using System;");
		WriteLine("");
		WriteLine("namespace " + DataTestMethodAttributeNamespace);
		WriteLine("{");
		PushIndent("\t");
		WriteLine("[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)]");
		WriteLine("internal class " + DataTestMethodAttributeName + " : Attribute");
		WriteLine("{");
		PushIndent("\t");
		WriteLine("public " + DataTestMethodAttributeName + "(params object[] args)");
        WriteLine("{");
		PushIndent("\t");
        WriteLine("if (args == null)");
		PushIndent("\t");
		WriteLine("Arguments = new object[] { null };");
		PopIndent();
		WriteLine("else");
		PushIndent("\t");
		WriteLine("Arguments = args;");
		PopIndent();
		PopIndent();
        WriteLine("}");

        WriteLine("public object[] Arguments { get; private set; }");
        WriteLine("public object Result { get; set; }");
        WriteLine("public string Message { get; set; }");
        WriteLine("public string TestName { get; set; }");
        WriteLine("public string Description { get; set; }");
        WriteLine("public Type ExpectedException { get; set; }");
        WriteLine("public bool Ignore { get; set; }");
        WriteLine("public int Priority { get; set; }");
        WriteLine("public int Timeout { get; set; }");
        WriteLine("public int WorkItem { get; set; }");
		PopIndent();
        WriteLine("}");
		PopIndent();
        WriteLine("}");
	}
#>
<#+
	const string DataTestMethodAttributeNamespace = "TemplateAttributes";
	const string DataTestMethodAttributeName = "DataTestMethodAttribute";
	const string DataTestMethodAttributeFullName = DataTestMethodAttributeNamespace + "." + DataTestMethodAttributeName;

	private void OutputUsings() 
	{
		WriteLine("using System;");
		WriteLine("using Microsoft.VisualStudio.TestTools.UnitTesting;");
		WriteLine("");
	}

	private FileCodeModel GetCodeModel(string filename)
	{
		var dte = (DTE)TransformationContext.Current.GetService(typeof(DTE));
		ProjectItem projectItem = dte.Solution.FindProjectItem(filename);
		return projectItem.FileCodeModel;
	}

	private void ProcessElements(CodeElements elements)
	{
		bool firstElement = true;
		foreach (CodeElement element in elements)
		{
			CodeNamespace codeNamespace = element as CodeNamespace;
			CodeClass codeClass = element as CodeClass;
			if (codeNamespace != null) 
			{
				ProcessNamespace(codeNamespace, !firstElement);
				firstElement = false;
			} else if (codeClass != null)
			{
				ProcessClass(codeClass, !firstElement);
				firstElement = false;
			}
		}
	}

	private void ProcessNamespace(CodeNamespace codeNamespace, bool emptyLineBefore)
	{
		if (emptyLineBefore) WriteLine("");
		WriteLine("namespace " + codeNamespace.Name);
		WriteLine("{");
		PushIndent("\t");
		ProcessElements(codeNamespace.Children);
		PopIndent();
		WriteLine("}");
	}

	private void ProcessClass(CodeClass codeClass, bool emptyLineBefore)
	{
		if (!IsPartialClass(codeClass)) return;

		bool isTestClass = HasTestClassAttribute(codeClass);

		OutputClassHeader(codeClass, emptyLineBefore);

		if (isTestClass)
			OutputClassTests(codeClass);

		bool firstElement = true;
		foreach (CodeElement element in codeClass.Children)
		{
			CodeClass innerCodeClass = element as CodeClass;
			if (innerCodeClass != null)
			{
				ProcessClass(innerCodeClass, !firstElement);
				firstElement = false;
			}
		}

		OutputClassFooter(codeClass);
	}

	private bool IsPartialClass(CodeClass codeClass)
	{
		EnvDTE80.CodeClass2 codeClass2 = codeClass as EnvDTE80.CodeClass2;
		return (codeClass2 != null) && (codeClass2.ClassKind == EnvDTE80.vsCMClassKind.vsCMClassKindPartialClass);
	}

	private bool HasTestClassAttribute(CodeClass codeClass)
	{
		foreach (CodeAttribute codeAttribute in codeClass.Attributes)
        {
            if (codeAttribute.FullName == "Microsoft.VisualStudio.TestTools.UnitTesting.TestClassAttribute") return true;
        }
		return false;
	}

	class DataTest
	{
		public DataTest(string dataTestMethodName, Dictionary<string, CodeAttribute> parentAttributes)
		{
			DataTestMethodName = dataTestMethodName;
			TestParameters = "";
			Parameters = new Dictionary<string, string>();
			_ParentAttributes = parentAttributes;
		}

		Dictionary<string, CodeAttribute> _ParentAttributes;

		public string DataTestMethodName { get; set; }
		public string TestParameters { get; set; }
		public Dictionary<string, string> Parameters { get; private set; }

		public void AddTestParameter(string param)
		{
			if (String.IsNullOrEmpty(TestParameters))
				TestParameters = param;
			else
				TestParameters += ", " + param;
		}

		public IEnumerable<string> GetTestAttributes()
		{
			List<string> ignoreAttributes = new List<string>();
			string param = null;

			bool ignore = false;
			if (Parameters.TryGetValue("Ignore", out param) && Boolean.TryParse(param, out ignore))
			{
				ignoreAttributes.Add("Microsoft.VisualStudio.TestTools.UnitTesting.IgnoreAttribute");
				if (ignore)
					yield return "Ignore";
			}

			foreach(string propName in new string[] { "Description", "Priority", "Timeout", "WorkItem" })
			{
				if (Parameters.TryGetValue(propName, out param) && !String.IsNullOrEmpty(param))
				{
					ignoreAttributes.Add("Microsoft.VisualStudio.TestTools.UnitTesting." + propName + "Attribute");
					yield return propName + "(" + param + ")";
				}
			}

			if (Parameters.TryGetValue("ExpectedException", out param) && !String.IsNullOrEmpty(param))
			{
				ignoreAttributes.Add("Microsoft.VisualStudio.TestTools.UnitTesting.ExpectedExceptionAttribute");
				string expectedException = "ExpectedException(" + param;
				if (Parameters.TryGetValue("Message", out param) && !String.IsNullOrEmpty(param))
				{
					expectedException += ", " + param;
				}
				expectedException += ")";
				yield return expectedException;
			}

			CodeAttribute descriptionAttribute;
			if (_ParentAttributes.TryGetValue("Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute", out descriptionAttribute) && descriptionAttribute != null)
			{
				try
				{
					param = descriptionAttribute.Value;
					ignoreAttributes.Add("Microsoft.VisualStudio.TestTools.UnitTesting.DescriptionAttribute");
					if (param.Contains("{"))
						param = "\"" + FormatDescription(param) + "\"";
				}
				catch (Exception e)
				{ 
					param = "\"Error formatting description string (" + e.Message + ")\"";
				}
				yield return "Description(" + param + ")";
			}

			foreach(KeyValuePair<string, CodeAttribute> parentAttr in _ParentAttributes)
			{
				if (!ignoreAttributes.Contains(parentAttr.Key))
					yield return parentAttr.Value.Name + "(" + parentAttr.Value.Value + ")";
			}
		}

        public string FormatDescription(string description)
        {
            var codeProvider = new Microsoft.CSharp.CSharpCodeProvider();
            var compilerParameters = new System.CodeDom.Compiler.CompilerParameters()
            {
                GenerateExecutable = false,
                GenerateInMemory = true
            };
			string stringFormatParameters = TestParameters;
			string result;
			if (Parameters.TryGetValue("Result", out result) && !String.IsNullOrEmpty(result))
				stringFormatParameters += ", " + result;
            string formatString = String.Format("String.Format({0}, {1});", description, stringFormatParameters);
            string fileContents = @"using System; namespace tmp { public static class tmpClass { public static string GetValue() { return " + formatString + " } } }";
            var results = codeProvider.CompileAssemblyFromSource(compilerParameters, fileContents);
            var method = results.CompiledAssembly.GetType("tmp.tmpClass").GetMethod("GetValue");
            return method.Invoke(null, null) as string;
        }

		public string GetTestMethodName()
		{
			string testName;
			if (Parameters.TryGetValue("TestName", out testName) && !String.IsNullOrEmpty(testName))
				return testName.Trim('"');

			string testMethodName = DataTestMethodName + "_" + TestParameters.Replace("\"", "").Replace(",", "_").Replace(" ", "");
			string result;
			if (Parameters.TryGetValue("Result", out result) && !String.IsNullOrEmpty(result))
				testMethodName += "_" + result;
			return testMethodName;
		}

		public string GetTestContents()
		{
			string testContents = DataTestMethodName + "(" + TestParameters + ")";
			string result;
			if (Parameters.TryGetValue("Result", out result) && !String.IsNullOrEmpty(result))
			{
				testContents = "Assert.AreEqual(" + result + ", " + testContents;
				string message;
				if (Parameters.TryGetValue("Message", out message) && !String.IsNullOrEmpty(message))
					testContents += ", " + message;
				testContents += ")";
			}

			return testContents + ";";
		}
	}

	private void OutputClassTests(CodeClass codeClass)
	{
		foreach(DataTest dataTest in GetDataTests(codeClass))
		{
			WriteLine("[TestMethod]");
			foreach(string attrib in dataTest.GetTestAttributes())
				WriteLine("[" + attrib + "]");
			WriteLine("public void " + dataTest.GetTestMethodName() + "()");
			WriteLine("{");
			PushIndent("\t");
			WriteLine(dataTest.GetTestContents());
			PopIndent();
			WriteLine("}");
		}
	}

	private IEnumerable<DataTest> GetDataTests(CodeClass codeClass)
	{
		foreach (CodeElement element in codeClass.Members)
		{
			CodeFunction codeFunction = element as CodeFunction;
			if (codeFunction != null)
			{
				List<CodeAttribute> dataTestAttributes = new List<CodeAttribute>();
				Dictionary<string, CodeAttribute> parentAttributes = new Dictionary<string, CodeAttribute>();
				foreach (CodeAttribute codeAttribute in codeFunction.Attributes)
				{
					if (codeAttribute.FullName == DataTestMethodAttributeFullName) 
					{
						dataTestAttributes.Add(codeAttribute);
					}
					else
					{
						parentAttributes.Add(codeAttribute.FullName, codeAttribute);
					}
				}
				foreach (CodeAttribute codeAttribute in dataTestAttributes)
				{
					WriteLine("// " + codeAttribute.Name + "(" + codeAttribute.Value + ")");
					DataTest dataTest = new DataTest(codeFunction.Name, parentAttributes);
					foreach (CodeElement child in codeAttribute.Children)
					{
						EnvDTE80.CodeAttributeArgument attributeArg = (EnvDTE80.CodeAttributeArgument)child;
						if (String.IsNullOrEmpty(attributeArg.Name))
							dataTest.AddTestParameter(attributeArg.Value);
						else
							dataTest.Parameters.Add(attributeArg.Name, attributeArg.Value);
					}
					yield return dataTest;
				}
			}
		}
	}

	private void OutputClassHeader(CodeClass codeClass, bool emptyLineBefore)
	{
		if (emptyLineBefore) WriteLine("");
		WriteLine("partial class " + codeClass.Name);
		WriteLine("{");
		PushIndent("\t");
	}

	private void OutputClassFooter(CodeClass codeClass)
	{
		PopIndent();
		WriteLine("}");
	}

	private void DumpElements(CodeElements elements)
	{
		foreach (CodeElement element in elements)
		{
			string elDump = element.Kind.ToString();
			if (element.Kind == vsCMElement.vsCMElementNamespace || element.Kind == vsCMElement.vsCMElementClass)
				elDump += ": " + element.Name;
			elDump += " -> " + element.Children.Count.ToString();
			WriteLine(elDump);
			DumpElements(element.Children);
		}
	}
#>